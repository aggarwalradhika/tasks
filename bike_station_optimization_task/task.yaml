prompt: |
  You need to optimize the placement of 5 new Citi Bike stations in Manhattan by analyzing historical ridership patterns, demographic data, and network connectivity to maximize projected daily ridership while satisfying multiple constraints.

  ## Your Task

  Analyze multi-source datasets to select optimal locations for 5 new bike-sharing stations that will maximize network efficiency and ridership.

  ## Data Files

  Load these files from `/workdir/data/`:
  - `existing_stations.json` - 100 current Citi Bike stations with historical ridership data
  - `candidate_locations.json` - 200 candidate locations for new stations
  - `manhattan_demographics.json` - Population density and commuter data by census tract
  - `poi_data.json` - Points of interest (offices, transit hubs, parks, etc.)
  - `weather_ridership.json` - Historical weather impact on ridership patterns
  - `time_patterns.json` - Hourly/daily ridership patterns

  ## Requirements

  Your 5-station network must satisfy ALL constraints:

  1. Coverage Constraint: Each new station must be ≥ 0.25 miles from any existing station
  2. Spacing Constraint: New stations must be ≥ 0.15 miles apart from each other
  3. Density Constraint: At least 3 of the 5 stations must be in "High Density" census tracts
  4. Transit Integration: At least 2 stations must be within 0.1 miles of a subway_station POI
  5. Network Balance: The coefficient of variation (std_dev/mean) of projected ridership across the 5 stations must be ≤ 0.35
  6. Geographic Diversity: Stations must span at least 3 different neighborhoods

  ## Scoring Formula

  Calculate the network score as:

  ```
  network_score = total_projected_ridership - (spacing_penalty + imbalance_penalty + isolation_penalty)
  ```

  ### Total Projected Ridership

  For each new station, calculate:

  ```
  projected_daily_ridership = 
    base_ridership 
    × demographic_multiplier 
    × poi_proximity_multiplier 
    × network_effect_multiplier
    × weather_adjustment
  ```

  Where:

  Base Ridership (from candidate_locations.json):
  - The `baseline_demand` field for each candidate location

  Demographic Multiplier:
  ```
  demographic_multiplier = 1.0 + (population_density_factor × 0.3) + (commuter_density_factor × 0.4)
  ```
  - `population_density_factor` = (tract_population_density - 20000) / 30000, capped at [0, 1]
  - `commuter_density_factor` = (tract_commuter_density - 5000) / 10000, capped at [0, 1]
  - Match each candidate to its census tract using the `census_tract_id` field

  POI Proximity Multiplier:
  ```
  poi_proximity_multiplier = 1.0 + Σ(poi_bonus for each POI within 0.15 miles)
  ```
  - office_building: +0.15
  - subway_station: +0.25
  - park: +0.10
  - university: +0.20
  - hospital: +0.12
  - retail_hub: +0.18
  - Maximum total bonus: +0.80 (cap at 1.80 multiplier)

  Network Effect Multiplier:
  ```
  network_effect_multiplier = 1.0 + (nearby_existing_stations_factor × 0.2)
  ```
  - Count existing stations within 0.5 miles (but > 0.25 miles to satisfy coverage constraint)
  - `nearby_existing_stations_factor` = min(count / 5, 1.0)

  Weather Adjustment:
  ```
  weather_adjustment = average of seasonal adjustment factors
  ```
  - Use `weather_ridership.json` to get seasonal multipliers
  - Average the spring, summer, fall, winter multipliers for the candidate's `weather_zone`

  ### Spacing Penalty

  ```
  spacing_penalty = Σ max(0, (0.20 - distance_between_new_stations) × 1000)
  ```
  - Sum over all pairs of new stations where distance < 0.20 miles
  - Encourages spacing but doesn't violate the 0.15 mile minimum constraint

  ### Imbalance Penalty

  ```
  imbalance_penalty = (coefficient_of_variation - 0.25) × 500 if CV > 0.25, else 0
  ```
  - CV = standard_deviation / mean of the 5 projected ridership values
  - Encourages balanced ridership across stations

  ### Isolation Penalty

  ```
  isolation_penalty = isolated_station_count × 200
  ```
  - A station is "isolated" if it has < 2 existing stations within 0.4 miles
  - Discourages placing stations in network dead zones

  ## Distance Calculations

  Use haversine distance formula with Earth radius = 3959 miles for all distance calculations.

  ## Your Output

  Save results to `/workdir/solution.json` as a single JSON file with the following structure:

  ```json
  {
    "selected_stations": [
      {
        "station_id": "CAND_XXX",
        "location_name": "string",
        "latitude": 40.1234,
        "longitude": -74.1234,
        "neighborhood": "string",
        "census_tract_id": "CT_XXX",
        "projected_daily_ridership": 123.4,
        "demographic_multiplier": 1.234,
        "poi_proximity_multiplier": 1.234,
        "network_effect_multiplier": 1.234,
        "weather_adjustment": 1.234,
        "nearby_existing_count": 3,
        "is_high_density": true,
        "near_transit": false,
        "is_isolated": false
      }
      // ... 4 more stations (5 total)
    ],
    "network_summary": {
      "total_projected_ridership": 1234.5,
      "spacing_penalty": 123.4,
      "imbalance_penalty": 12.3,
      "isolation_penalty": 200.0,
      "network_score": 2898.8,
      "ridership_coefficient_of_variation": 0.123,
      "constraints_satisfied": {
        "coverage_constraint": true,
        "spacing_constraint": true,
        "density_constraint": true,
        "transit_integration": true,
        "network_balance": true,
        "geographic_diversity": true
      },
      "min_distance_between_new_stations": 0.234,
      "min_distance_to_existing": 0.345,
      "neighborhoods_represented": ["East Village", "SoHo", "Chelsea"]
    }
  }
  ```

  Field specifications for `selected_stations`:
  - `station_id`: The candidate location ID from candidate_locations.json
  - `location_name`: The name from candidate_locations.json
  - `latitude`, `longitude`: From candidate_locations.json (4 decimal places)
  - `neighborhood`: From candidate_locations.json
  - `census_tract_id`: From candidate_locations.json
  - `projected_daily_ridership`: Calculated value (1 decimal place)
  - `demographic_multiplier`: Calculated value (3 decimal places)
  - `poi_proximity_multiplier`: Calculated value (3 decimal places)
  - `network_effect_multiplier`: Calculated value (3 decimal places)
  - `weather_adjustment`: Calculated value (3 decimal places)
  - `nearby_existing_count`: Integer count of existing stations within 0.5 miles (but > 0.25)
  - `is_high_density`: Boolean - true if census tract density_category is "High Density"
  - `near_transit`: Boolean - true if within 0.1 miles of any subway_station POI
  - `is_isolated`: Boolean - true if < 2 existing stations within 0.4 miles

  ## Important Notes

  - Find the configuration with the HIGHEST network_score
  - All constraints must be satisfied (constraints_satisfied must all be true)
  - Round numeric values appropriately (ridership: 1 decimal, multipliers: 3 decimals, coordinates: 4 decimals)
  - Use haversine distance for all calculations (Earth radius = 3959 miles)
  - The solution file must be valid JSON

  ## Success Criteria

  Your solution will be graded as PASS (1.0) if:
  1. /workdir/solution.json exists and is valid JSON
  2. The file has exactly 5 stations in the selected_stations array
  3. All station_ids exist in candidate_locations.json
  4. All 6 constraints are satisfied
  5. All multipliers and projected ridership values are calculated correctly (±0.01 tolerance)
  6. Spacing penalty, imbalance penalty, and isolation penalty are calculated correctly (±1.0 tolerance)
  7. Network score is calculated correctly (±1.0 tolerance)
  8. Your network score is within 50 points of the optimal solution (≥ optimal_score - 50)
  
  The 50-point tolerance accounts for different optimization strategies (heuristic vs exhaustive search) while still requiring a high-quality solution. Invalid solutions (constraint violations) will receive 0.0 regardless of score.

  Otherwise, you will receive FAIL (0.0) with a specific error message.

metadata:
  difficulty: very_hard
  category: optimization
  tags:
    - data_science
    - geospatial
    - time_series
    - optimization
    - multi_objective
  time_limit: 3600
  memory_limit: 4096