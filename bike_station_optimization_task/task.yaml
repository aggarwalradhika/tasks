prompt: |
  You need to optimize the placement of 5 new Citi Bike stations in Manhattan by analyzing historical ridership patterns, demographic data, and network connectivity to maximize projected daily ridership while satisfying multiple constraints.

  ## Your Task

  Analyze multi-source datasets to select optimal locations for 5 new bike-sharing stations that will maximize network efficiency and ridership.

  ## Data Files

  Load these files from `/workdir/data/`:
  - `existing_stations.json` - 100 current Citi Bike stations with historical ridership data
  - `candidate_locations.json` - 200 candidate locations for new stations
  - `manhattan_demographics.json` - Population density and commuter data by census tract
  - `poi_data.json` - Points of interest (offices, transit hubs, parks, etc.)
  - `weather_ridership.json` - Historical weather impact on ridership patterns
  - `time_patterns.json` - Hourly/daily ridership patterns

  ## Requirements

  Your 5-station network must satisfy ALL constraints:

  1. **Coverage Constraint**: Each new station must be ≥ 0.25 miles from any existing station
  2. **Spacing Constraint**: New stations must be ≥ 0.15 miles apart from each other
  3. **Density Constraint**: At least 3 of the 5 stations must be in "High Density" census tracts
  4. **Transit Integration**: At least 2 stations must be within 0.1 miles of a subway_station POI
  5. **Network Balance**: The coefficient of variation (std_dev/mean) of projected ridership across the 5 stations must be ≤ 0.35
  6. **Geographic Diversity**: Stations must span at least 3 different neighborhoods

  ## Scoring Formula

  Calculate the network score as:

  ```
  network_score = total_projected_ridership - (spacing_penalty + imbalance_penalty + isolation_penalty)
  ```

  ### Total Projected Ridership

  For each new station, calculate:

  ```
  projected_daily_ridership = 
    base_ridership 
    × demographic_multiplier 
    × poi_proximity_multiplier 
    × network_effect_multiplier
    × weather_adjustment
  ```

  Where:

  **Base Ridership** (from candidate_locations.json):
  - The `baseline_demand` field for each candidate location

  **Demographic Multiplier**:
  ```
  demographic_multiplier = 1.0 + (population_density_factor × 0.3) + (commuter_density_factor × 0.4)
  ```
  - `population_density_factor` = (tract_population_density - 20000) / 30000, capped at [0, 1]
  - `commuter_density_factor` = (tract_commuter_density - 5000) / 10000, capped at [0, 1]
  - Match each candidate to its census tract using the `census_tract_id` field

  **POI Proximity Multiplier**:
  ```
  poi_proximity_multiplier = 1.0 + Σ(poi_bonus for each POI within 0.15 miles)
  ```
  - office_building: +0.15
  - subway_station: +0.25
  - park: +0.10
  - university: +0.20
  - hospital: +0.12
  - retail_hub: +0.18
  - Maximum total bonus: +0.80 (cap at 1.80 multiplier)

  **Network Effect Multiplier**:
  ```
  network_effect_multiplier = 1.0 + (nearby_existing_stations_factor × 0.2)
  ```
  - Count existing stations within 0.5 miles (but > 0.25 miles to satisfy coverage constraint)
  - `nearby_existing_stations_factor` = min(count / 5, 1.0)

  **Weather Adjustment**:
  ```
  weather_adjustment = average of seasonal adjustment factors
  ```
  - Use `weather_ridership.json` to get seasonal multipliers
  - Average the spring, summer, fall, winter multipliers for the candidate's `weather_zone`

  ### Spacing Penalty

  ```
  spacing_penalty = Σ max(0, (0.20 - distance_between_new_stations) × 1000)
  ```
  - Sum over all pairs of new stations where distance < 0.20 miles
  - Encourages spacing but doesn't violate the 0.15 mile minimum constraint

  ### Imbalance Penalty

  ```
  imbalance_penalty = (coefficient_of_variation - 0.25) × 500 if CV > 0.25, else 0
  ```
  - CV = standard_deviation / mean of the 5 projected ridership values
  - Encourages balanced ridership across stations

  ### Isolation Penalty

  ```
  isolation_penalty = isolated_station_count × 200
  ```
  - A station is "isolated" if it has < 2 existing stations within 0.4 miles
  - Discourages placing stations in network dead zones

  ## Distance Calculations

  Use haversine distance formula with Earth radius = 3959 miles for all distance calculations.

  ## Your Output

  Save results to `/workdir/sol.csv` with exactly 5 rows (plus header), one per new station.

  Required columns:
  ```
  station_id,location_name,latitude,longitude,neighborhood,census_tract_id,projected_daily_ridership,demographic_multiplier,poi_proximity_multiplier,network_effect_multiplier,weather_adjustment,nearby_existing_count,is_high_density,near_transit,is_isolated
  ```

  Column specifications:
  - `station_id`: The candidate location ID from candidate_locations.json
  - `location_name`: The name from candidate_locations.json
  - `latitude`, `longitude`: From candidate_locations.json (4 decimal places)
  - `neighborhood`: From candidate_locations.json
  - `census_tract_id`: From candidate_locations.json
  - `projected_daily_ridership`: Calculated value (1 decimal)
  - `demographic_multiplier`: Calculated value (3 decimals)
  - `poi_proximity_multiplier`: Calculated value (3 decimals)
  - `network_effect_multiplier`: Calculated value (3 decimals)
  - `weather_adjustment`: Calculated value (3 decimals)
  - `nearby_existing_count`: Integer count of existing stations within 0.5 miles (but > 0.25)
  - `is_high_density`: Boolean (True/False) if census tract density_category is "High Density"
  - `near_transit`: Boolean (True/False) if within 0.1 miles of any subway_station POI
  - `is_isolated`: Boolean (True/False) if < 2 existing stations within 0.4 miles

  Additionally, create `/workdir/network_summary.json` with:
  ```json
  {
    "total_projected_ridership": <float>,
    "spacing_penalty": <float>,
    "imbalance_penalty": <float>,
    "isolation_penalty": <float>,
    "network_score": <float>,
    "ridership_coefficient_of_variation": <float>,
    "constraints_satisfied": {
      "coverage_constraint": <bool>,
      "spacing_constraint": <bool>,
      "density_constraint": <bool>,
      "transit_integration": <bool>,
      "network_balance": <bool>,
      "geographic_diversity": <bool>
    },
    "min_distance_between_new_stations": <float>,
    "min_distance_to_existing": <float>,
    "neighborhoods_represented": [<list of strings>]
  }
  ```

  ## Important Notes

  - Find the configuration with the HIGHEST network_score
  - All constraints must be satisfied (constraints_satisfied must all be true)
  - Round numeric values appropriately (ridership: 1 decimal, multipliers: 3 decimals, coordinates: 4 decimals)
  - Use haversine distance for all calculations (Earth radius = 3959 miles)
  - Boolean fields should be exactly "True" or "False" (capital T/F)

  ## Success Criteria

  Your solution will be graded as PASS (1.0) if:
  1. Both sol.csv and network_summary.json exist and are valid
  2. sol.csv has exactly 5 rows with all required columns
  3. All station_ids exist in candidate_locations.json
  4. All 6 constraints are satisfied
  5. All multipliers and projected ridership values are calculated correctly (±0.01 tolerance)
  6. Spacing penalty, imbalance penalty, and isolation penalty are calculated correctly (±1.0 tolerance)
  7. Network score is calculated correctly (±1.0 tolerance)
  8. Your network score is within 50 points of the optimal solution (≥ optimal_score - 50)
  
  The 50-point tolerance accounts for different optimization strategies (heuristic vs exhaustive search) while still requiring a high-quality solution. Invalid solutions (constraint violations) will receive 0.0 regardless of score.

  Otherwise, you will receive FAIL (0.0) with a specific error message.

metadata:
  difficulty: very_hard
  category: optimization
  tags:
    - data_science
    - geospatial
    - time_series
    - optimization
    - multi_objective
  time_limit: 3600
  memory_limit: 4096