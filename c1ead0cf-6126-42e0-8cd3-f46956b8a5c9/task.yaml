prompt: |
  You are working at OpenAI on infrastructure for GPT-5, an extremely large neural network that requires specialized GPU allocation.
  
  ## Your Task
  
  Design an optimal schedule to minimize the maximum weighted completion time across all customer requests.
  
  ## Problem Details
  
  - You have `n` GPUs available (GPU1, GPU2, ..., GPUn)
  - You have `m` unique customer requests to schedule
  - Each request has a **priority level** from 1 to 5:
    * priority = 5 → "Ultra Fast" tier (premium customers, 5x weight)
    * priority = 4 → "Fast" tier (4x weight)
    * priority = 3 → "Standard Plus" tier (3x weight)
    * priority = 2 → "Standard" tier (2x weight)
    * priority = 1 → "Economy" tier (1x weight)
  - Each request can run on any GPU, but with different execution times
  - **Each request must be assigned to exactly ONE GPU**
  - Requests assigned to the same GPU execute sequentially (no parallelism within a GPU)
  - **NEW: Some requests have dependencies** - request X must complete before request Y starts
  
  ## Objective
  
  Minimize the **maximum weighted completion time** across all requests while respecting dependencies.
  
  **Definitions:**
  - `completion_time` = the time when a request finishes execution
    - If GPU is busy, the request waits in queue
    - If request has dependencies, it can't start until all dependencies complete
    - completion_time = max(GPU_available_time, dependencies_complete_time) + execution_time
  - `weighted_completion_time = priority × completion_time`
  - **Goal:** Minimize `max(weighted_completion_time)` across all requests
  
  ## Why This Matters
  
  High-priority customers pay premium rates and expect fast service. A customer with priority=5 who waits 100 seconds has a weighted completion time of 500, which is far worse than a regular customer (priority=1) waiting 400 seconds (weighted CT = 400). Your schedule must balance priorities, execution times, AND dependencies.
  
  ## Input Format
  
  The file `/workdir/data/requests.txt` contains:
  
  ```
  n m d
  <request_id> <priority> <GPU_id> <execution_time_seconds>
  <request_id> <priority> <GPU_id> <execution_time_seconds>
  ...
  [blank line]
  <request_id_A> <request_id_B>
  <request_id_C> <request_id_D>
  ...
  ```
  
  - First line: `n` (number of GPUs), `m` (number of unique requests), `d` (number of dependencies)
  - Next section: For each request, there are `n` lines showing execution time on each GPU
  - After blank line: `d` dependency lines where "A B" means A must complete before B starts
  
  **Example:**
  ```
  3 4 2
  req1 2 GPU1 10
  req1 2 GPU2 8
  req1 2 GPU3 12
  req2 5 GPU1 5
  req2 5 GPU2 6
  req2 5 GPU3 7
  req3 1 GPU1 7
  req3 1 GPU2 9
  req3 1 GPU3 6
  req4 3 GPU1 15
  req4 3 GPU2 12
  req4 3 GPU3 18
  
  req1 req4
  req2 req4
  ```
  
  This means:
  - 3 GPUs, 4 requests, 2 dependencies
  - req1 (priority=2), req2 (priority=5), req3 (priority=1), req4 (priority=3)
  - req4 cannot start until BOTH req1 AND req2 have completed
  
  ## Output Format
  
  You must produce **TWO files**:
  
  ### 1. `/workdir/schedule.txt` - Your scheduling decisions
  
  One line per request:
  ```
  <request_id> <assigned_GPU_id>
  ```
  
  **CRITICAL: The order of lines in schedule.txt determines the execution order.**
  - Requests assigned to the same GPU will execute in the order they appear in the file
  - The first occurrence of a GPU assignment executes first on that GPU
  - You must write the schedule in the order you want requests to execute
  - **You must respect dependencies**: A dependent request should appear AFTER all its prerequisites
  
  Example:
  ```
  req2 GPU1
  req1 GPU2
  req3 GPU3
  req4 GPU1
  ```
  
  This means:
  - GPU1: req2 first (completes at 5 sec, WCT=5×5=25), then req4 (must wait for req1 too)
  - GPU2: req1 (completes at 8 sec, WCT=2×8=16)
  - GPU3: req3 (completes at 6 sec, WCT=1×6=6)
  - req4 on GPU1 can start at max(5, 8) = 8 sec (must wait for both req2 and req1)
  - req4 completes at 8+15=23 sec, WCT=3×23=69
  - Maximum WCT = 69
  
  ### 2. `/workdir/ans.txt` - The optimal value
  
  A single integer: the maximum weighted completion time from your schedule.
  
  Example:
  ```
  69
  ```
  
  ## Constraints
  
  - 3 ≤ n ≤ 10 (number of GPUs) - INCREASED
  - 20 ≤ m ≤ 100 (number of requests) - INCREASED
  - 0 ≤ d ≤ min(50, m*(m-1)/4) (number of dependencies)
  - 1 ≤ execution_time ≤ 200 seconds - INCREASED
  - priority ∈ {1, 2, 3, 4, 5} - INCREASED
  - Dependencies form a DAG (no cycles)
  - You do NOT have internet access
  - Python 3 is available
  
  ## Important Notes
  
  1. **This is NP-hard**: There's no known polynomial-time optimal algorithm. Use sophisticated heuristics/approximation algorithms.
  
  2. **Your schedule will be validated**: The grader will:
     - Check that every request is assigned exactly once
     - Verify the schedule is feasible (respects dependencies)
     - Compute the actual max weighted CT from your schedule
     - Check that it matches your claimed answer in ans.txt
     - Verify your solution is near-optimal (within 1.15x of a sophisticated baseline) - TIGHTENED
  
  3. **Think algorithmically**: Consider approaches like:
     - Topological sorting for dependencies
     - Critical path analysis
     - List scheduling with priority queues
     - Dynamic programming (if feasible)
     - Local search / simulated annealing
     - Branch and bound with pruning
     - Genetic algorithms
  
  4. **Be deterministic**: If your algorithm has ties, break them consistently.
  
  5. **Test your solution**: Manually verify a small example to ensure dependency handling is correct.
  
  6. **Near-optimality tolerance**: Your solution must achieve a score within 1.15x (115%) of a sophisticated baseline. This is tighter than before - you need a really good algorithm!

metadata:
  difficulty: very_hard
  category: optimization algorithms
  tags:
    - scheduling
    - greedy algorithms
    - resource allocation
    - NP-hard optimization
    - weighted completion time
    - dependency graphs
    - topological sorting
  references:
    - "Inspired by weighted completion time minimization with precedence constraints"
    - "Related to RCPSP (Resource-Constrained Project Scheduling Problem)"
    - "Connection to critical path method (CPM) and PERT"