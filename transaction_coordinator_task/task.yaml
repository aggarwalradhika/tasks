prompt: |
  ## Task Overview
  Implement a distributed transaction coordinator using Two-Phase Commit (2PC) with Paxos consensus for fault tolerance. Process a transaction log and output transaction results.

  ## Input File
  `/workdir/data/transaction_log.jsonl` - JSONL file with transaction events

  ## Event Types
  1. partition_definition: Define data partitions
     - `partition_id`, `key_range_start`, `key_range_end`, `replica_nodes`, `replication_factor`

  2. txn_begin: Start transaction
     - `txn_id`, `coordinator_id`, `isolation_level` (serializable|snapshot|read_committed), `timestamp`

  3. txn_operation: Transaction operation
     - `txn_id`, `operation` (read|write|delete), `partition_id`, `key`, `value`, `predicate`, `timestamp`

  4. txn_commit: Commit request - triggers 2PC protocol
     - `txn_id`, `timestamp`

  5. txn_abort: Explicit abort
     - `txn_id`, `reason`, `timestamp`

  6. node_failure: Node crashes or partitions
     - `node_id`, `failure_type` (crash|partition|slow), `duration_ms`, `timestamp`

  7. node_recovery: Node recovers
     - `node_id`, `timestamp`

  8. consensus_proposal: Paxos proposal (Phase 1a)
     - `proposal_id`, `proposer_id`, `round`, `value`, `timestamp`

  9. consensus_vote: Paxos vote (Phase 1b/2b)
     - `proposal_id`, `voter_id`, `vote` (promise|accept|reject), `promised_round`, `timestamp`

  10. checkpoint: Save/restore state
      - `checkpoint_id`, `action` (save|restore), `scope`, `node_id`

  ## Core Algorithm: Two-Phase Commit (2PC)
  
  Phase 1 - PREPARE:
  - Coordinator sends PREPARE to all participant partitions
  - Each participant: check quorum availability, acquire locks, vote YES/NO
  - If any NO or timeout → abort transaction
  
  Phase 2 - COMMIT/ABORT:
  - Coordinator logs decision, sends to all participants
  - Participants apply changes and release locks
  
  Coordinator Failure: Use Paxos to elect new coordinator and agree on decision

  ## Isolation Levels
  
  SERIALIZABLE:
  - Acquire shared locks for reads, exclusive locks for writes
  - Hold all locks until commit (strict 2PL)
  - Acquire predicate locks for range queries (phantom prevention)
  
  SNAPSHOT:
  - Multi-version concurrency control (MVCC)
  - Transaction sees snapshot at begin_timestamp
  - First-committer-wins: detect write-write conflicts at commit time
  - No read locks needed
  
  READ_COMMITTED:
  - Acquire write locks (hold until commit)
  - Acquire read locks (release immediately)

  ## Lock Compatibility
  ```
       | S | X | U
    ---+---+---+---
     S | ✓ | ✗ | ✓
     X | ✗ | ✗ | ✗
     U | ✓ | ✗ | ✗
  ```

  ## Deadlock Detection
  - Build wait-for graph (T1 → T2 if T1 waits for lock held by T2)
  - If cycle detected: abort younger transaction (by begin_timestamp)
  - Lock timeout: `lock_timeout_ms = 10000`

  ## Paxos Consensus (for coordinator election)
  - Used when coordinator fails during 2PC
  - Requires quorum: ⌈n/2⌉ + 1 where n = total nodes
  - Simplified: choose first available node as new coordinator
  - Set `consensus_rounds = 1` for transaction

  ## Output Format
  Write `/workdir/sol.csv` with ONE row per transaction (sorted by txn_id):

  Columns:
  ```
  txn_id,status,coordinator_id,participants,num_operations,isolation_level,
  commit_timestamp,abort_reason,locks_acquired,conflicts_detected,
  prepare_votes,consensus_rounds,recovery_needed,execution_time_ms,snapshot_version
  ```

  Field Details:
  - `status`: committed | aborted | in_progress
  - `coordinator_id`: node coordinating this transaction
  - `participants`: comma-separated partition IDs (e.g., "p1,p2")
  - `num_operations`: count of operations
  - `isolation_level`: serializable | snapshot | read_committed
  - `commit_timestamp`: timestamp when committed (or null)
  - `abort_reason`: reason for abort (or null)
  - `locks_acquired`: comma-separated locks "partition:key:type" (empty after commit/abort)
  - `conflicts_detected`: comma-separated conflicting txn_ids
  - `prepare_votes`: "partition:YES" or "partition:NO" (e.g., "p1:YES,p2:NO")
  - `consensus_rounds`: Paxos rounds for coordinator election (0 if none)
  - `recovery_needed`: true if transaction recovered after coordinator failure
  - `execution_time_ms`: commit_time - begin_time
  - `snapshot_version`: snapshot timestamp for snapshot isolation (or null)

  ## Key Rules
  
  2PC Prepare Phase:
  - Check partition quorum: need ⌈replication_factor/2⌉ + 1 reachable replicas
  - For snapshot isolation: check write-write conflicts (first-committer-wins)
  - Acquire locks based on operation type and isolation level
  - Vote YES if all checks pass, NO otherwise

  2PC Commit Phase:
  - Apply writes to partitions (MVCC: keep multiple versions)
  - Release all locks
  - Set status = committed, record commit_timestamp

  Coordinator Failure:
  - If coordinator fails: run Paxos to elect new coordinator
  - New coordinator inherits transaction, sets `recovery_needed = true`
  - Increment `consensus_rounds`
  - If can't reach quorum: abort with "coordinator_failed_no_quorum"

  Participant Failure:
  - If partition can't reach quorum during prepare: abort with "partition_unreachable"

  Write Conflicts (Snapshot Isolation):
  - Check if any committed write to same key occurred after snapshot_version
  - If yes: abort with "write_conflict", record conflicting txn_id

  Deadlocks:
  - Detect cycles in wait-for graph
  - Abort younger transaction with "deadlock_victim"

  Lock Timeouts:
  - If transaction holds locks > 10000ms: abort with "lock_timeout"

  Empty Transaction:
  - No operations: commit immediately without 2PC

  ## Special Cases
  - Blank lines and lines starting with '//' are ignored
  - Missing `stream_id`: auto-assign sequentially
  - Missing `timestamp`: use previous + 1
  - Locks are released during commit, so `locks_acquired` is empty in output
  - Format null values as "null", booleans as "true"/"false"
  - Empty lists as empty string ""

  ## Example
  ```
  // Partition definition
  {"type": "partition_definition", "partition_id": "p1", "replica_nodes": ["node1","node2","node3"]}

  // Simple transaction
  {"type": "txn_begin", "txn_id": "txn001", "coordinator_id": "node1", "isolation_level": "serializable", "timestamp": 1000}
  {"type": "txn_operation", "txn_id": "txn001", "operation": "write", "partition_id": "p1", "key": "acc1", "value": {"balance": 100}, "timestamp": 1001}
  {"type": "txn_commit", "txn_id": "txn001", "timestamp": 1002}

  // Output CSV:
  txn001,committed,node1,p1,1,serializable,1002,null,,,p1:YES,0,false,2,null
  ```

metadata:
  difficulty: expert
  category: distributed-systems
  tags: [distributed-transactions, 2pc, paxos, concurrency-control]

time_limit: 7200
memory_limit: 1024
max_agent_timeout_sec: 3600
expert_time_estimate_min: 480
junior_time_estimate_min: 960