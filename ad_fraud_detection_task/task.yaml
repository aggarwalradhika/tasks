prompt: |
  Cross-Channel Ad Fraud Detection (select exactly 5 campaigns with highest fraud_score)

  Files (JSON, read-only):
  /workdir/data/campaigns.json
  /workdir/data/impressions.json
  /workdir/data/clicks.json
  /workdir/data/conversions.json
  /workdir/data/ip_metadata.json

  Eligibility (campaign-level):
  • campaign.active == true
  • campaign.spend_last_30d ≥ 500
  • at least 2000 impressions across channels in last 30 days

  Fraud components (compute exactly):
  1) abnormal_click_rate:
     • For each campaign channel in campaign.channels, compute per-channel CTR = (clicks on that channel) / (impressions on that channel).
       - If impressions == 0 for a channel, treat that channel’s CTR as 0.0 (no division-by-zero).
       - Ignore channels not listed in campaign.channels.
     • channel_ctr_max = max CTR across the campaign’s channels (after the rule above).
     • expected_ctr:
         - If campaigns.average_ctr_by_channel is a NON-EMPTY dict → expected_ctr = arithmetic mean of ALL its values (not weighted).
         - If campaigns.average_ctr_by_channel is MISSING or is an EMPTY dict → expected_ctr = 0.02.
     • abnormal_click_rate = max(0, channel_ctr_max − expected_ctr)

  2) ip_aggregation_score:
     • Consider ONLY clicks tied to the campaign. Let total_clicks = total campaign clicks (across all channels).
     • Sum clicks from the top 3 IPs by click count → top3_clicks.
     • ip_aggregation_score = min(1.0, top3_clicks / total_clicks). If total_clicks == 0 → score = 0.0.

  3) rapid_fire_clicks:
     • Bucket campaign clicks per minute using UTC minute boundaries (YYYY-MM-DDTHH:MM from the click timestamp).
     • Let burst_minutes = count of minutes with >5 clicks; total_minutes = number of distinct minutes with ≥1 click.
       - If total_minutes == 0 → rapid_fire_clicks = 0.0.
     • rapid_click_burst_fraction = burst_minutes / total_minutes.
     • rapid_fire_clicks = clamp(rapid_click_burst_fraction, 0, 1).

  4) conversion_quality_penalty:
     • conversion_rate = (campaign conversions) / (campaign clicks). If clicks == 0 → conversion_rate = 0.0.
     • expected_conversion_rate:
         - If present and >0 use campaign.expected_conversion_rate.
         - Else fallback = 0.05.
     • If conversion_rate < expected_conversion_rate:
         penalty = (expected_conversion_rate − conversion_rate) / expected_conversion_rate
       Else penalty = 0.0.
     • Cap penalty to [0, 1].

  Final fraud score:
  fraud_score = 4.0*abnormal_click_rate + 3.0*ip_aggregation_score + 2.0*rapid_fire_clicks + 3.5*conversion_quality_penalty

  Selection & ordering:
  • Consider only eligible campaigns.
  • Sort by fraud_score descending; tie-break by campaign.account_id, campaign.campaign_id.
  • Take top 5; assign rank=1..5 (1 highest fraud_score).

  Output (CSV → /workdir/sol.csv; exact header & order):
  account_id,campaign_id,campaign_name,spend_last_30d,abnormal_click_rate,ip_aggregation_score,rapid_fire_clicks,conversion_quality_penalty,fraud_score,rank

  Formatting:
  spend_last_30d:2dp; abnormal_click_rate:3dp; ip_aggregation_score:3dp; rapid_fire_clicks:3dp;
  conversion_quality_penalty:3dp; fraud_score:3dp; rank:1..5
  Exactly 5 rows. No extra columns. No index.

metadata:
  difficulty: hard
  category: "ad-ops"
  tags: ["fraud-detection","ads","clickstream","anomaly-detection","attribution"]
  references: ["N/A"]
time_limit: 900          # seconds
memory_limit: 1024       # MB
max_agent_timeout_sec: 600
expert_time_estimate_min: 45
junior_time_estimate_min: 120
