prompt: |
  You are working at Meta on the infrastructure for their global content delivery network (CDN) serving users across multiple continents.
  
  ## Your Task
  
  Design an optimal data placement and replication strategy to minimize the total weighted cost across all user requests, considering access latency, network transfer costs, and replication overhead.
  
  ## Problem Details - Multi-Region CDN with Replication
  
  - You have `n` cache servers across `r` geographic regions (US-East, EU-West, Asia-Pacific, etc.)
  - You have `m` unique data objects that need to be cached
  - You have `u` user groups in different regions making requests
  - Each data object has a popularity score from 1 to 5 representing importance
  - KEY COMPLEXITY: Each object can be replicated to MULTIPLE caches (but costs increase with replicas)
  - Each cache server has a limited capacity and each region has network bandwidth limits
  - Dependencies exist between objects (accessing X may require Y to be available)
  - Inter-region transfers have costs when dependencies are in different regions
  - User requests come from specific regions and route to nearest replica
  
  ## Objective - Multi-Component Cost Minimization
  
  Minimize the total weighted cost which includes:
  
  1. Access Latency Cost: Sum of (popularity × request_volume × effective_latency) for all user-object pairs
     - effective_latency = base_latency if same region, else base_latency × 1.5
     - CRITICAL: The 1.5× cross-region penalty represents additional network overhead, routing latency, and potential congestion
     - Users route to the nearest replica of an object (considering the penalty)
     - This penalty applies even if the object is in a "nearby" region
     
  2. Replication Cost: Sum of (size × replication_penalty × num_replicas) for all objects
     - More replicas = higher storage/sync costs
     - replication_penalty = 2^(num_replicas - 1) (exponential growth)
     - Examples: 1 replica = 1×, 2 replicas = 2×, 3 replicas = 4×, 4 replicas = 8×, 5 replicas = 16×
     
  3. Cross-Region Transfer Cost: Sum of (size × transfer_cost × dependency_hops)
     - When object A depends on B, and they're in different regions
     - transfer_cost varies by region pair (e.g., US↔Asia expensive, US↔Canada cheap)
     - Uses maximum cost across all region pairs (worst-case scenario)
     
  4. Bandwidth Saturation Penalty: Quadratic penalty when region bandwidth is heavily utilized
     - Each region has max bandwidth (GB/hour)
     - penalty = max(0, (usage - 0.8×capacity)²) × 100
     - Bandwidth usage is calculated as total cross-region data transfer
     - When users access objects not in their region, it counts toward bandwidth usage
  
  Total Cost = α₁×AccessCost + α₂×ReplicationCost + α₃×TransferCost + α₄×BandwidthPenalty
  
  Where α₁=10, α₂=1, α₃=5, α₄=20 (weights are specified in input file)
  
  ## Constraints - HARD REQUIREMENTS
  
  Your solution MUST satisfy these constraints or it will be rejected:
  
  1. Replication: Each object must be replicated to 1-5 caches (inclusive)
  2. Capacity: Total size of objects on each cache must not exceed cache capacity
  3. Bandwidth: Total cross-region bandwidth usage per region must not exceed region bandwidth capacity
     - CRITICAL: This is a HARD constraint, not just a penalty
     - Solutions violating bandwidth limits are INVALID and will fail grading
     - Your solution must validate this before outputting results
  4. Dependencies: Must form a DAG (Directed Acyclic Graph) - no circular dependencies
  
  ## Algorithm Design Guidance
  
  This section provides guidance on how to derive effective heuristics from the problem specification.
  
  ### 1. Object Importance Scoring
  
  Problem: Which objects should get more replicas?
  
  Derivable from specification:
  - Access cost weight (α₁=10) is 10× larger than replication cost (α₂=1)
  - This means reducing latency is much more valuable than saving storage
  - Objects with high (popularity × access_frequency) have the most impact on access cost
  - Objects with dependents affect multiple other objects
  
  Suggested formula:
  ```
  importance = popularity × total_accesses × (1 + num_dependents × factor)
  ```
  Where factor ∈ [0.1, 0.5] weights dependency importance
  
  Rationale: This directly optimizes the dominant cost component (access latency)
  
  ### 2. Replication Strategy
  
  Problem: How many replicas should each object have?
  
  Derivable from specification:
  - Replication cost grows exponentially: 2^(n-1)
  - 3 replicas costs 4× more per MB than 1 replica
  - Only high-value objects justify high replication cost
  
  Suggested approach:
  ```
  Rank objects by importance
  Top X% → 3 replicas (high-value content)
  Next Y% → 2 replicas (medium-value content)  
  Rest → 1 replica (long-tail content)
  ```
  Where X ∈ [5%, 20%], Y ∈ [10%, 40%]
  
  Rationale: Aligns replication cost with value (importance)
  
  ### 3. Cache Selection Scoring
  
  Problem: Which caches should host each replica?
  
  Derivable from specification:
  - Access cost = popularity × frequency × latency
  - Cross-region access has 1.5× penalty
  - Same-region placement avoids both latency penalty and bandwidth usage
  
  Suggested scoring:
  ```
  For each cache:
    score = Σ(freq × (MAX_LATENCY - effective_latency)) for all users
    where effective_latency = latency × 1.0 (same region) or 1.5 (cross-region)
  ```
  
  Rationale: Maximizes benefit (reduced latency) for placement decision
  
  ### 4. Region Diversity for Replicas
  
  Problem: Should replicas be in same or different regions?
  
  Derivable from specification:
  - Users in different regions → high latency if all replicas in one region
  - Cross-region penalty (1.5×) makes this expensive
  - But multiple replicas in one region saves bandwidth
  
  Suggested strategy:
  ```
  For objects with 2+ replicas:
    First replica → highest affinity region
    Second replica → different high-affinity region (if significant demand)
    Third replica → third region (only if widely accessed)
  ```
  
  Rationale: Balances latency reduction with replication cost
  
  ### 5. Bandwidth Management
  
  Problem: How to avoid bandwidth violations?
  
  Derivable from specification:
  - Bandwidth is HARD constraint (solutions must satisfy it)
  - Bandwidth usage = Σ(size × frequency) for cross-region accesses
  - Placing replica in user's region eliminates bandwidth cost
  
  Required approach:
  ```
  After generating solution:
    1. Calculate bandwidth usage per region
    2. If any region exceeds capacity:
       - Remove low-value cross-region replicas
       - Add in-region replicas for high-access objects
    3. Repeat until constraints satisfied
  ```
  
  Rationale: Bandwidth is non-negotiable; must be validated and enforced
  
  ### 6. Multi-Start Search
  
  Problem: How to explore solution space?
  
  Derivable from specification:
  - Problem is NP-hard (facility location + replication + load balancing)
  - Local optima are common
  - Different initial strategies explore different trade-offs
  
  Suggested approach:
  ```
  Try multiple initial configurations:
    - Conservative replication (low X%, low Y%)
    - Aggressive replication (high X%, high Y%)
    - Balanced approaches
  Choose best result
  ```
  
  Rationale: Increases chance of finding good solution in complex space
  
  ### 7. Local Search Operators
  
  Problem: How to improve initial solution?
  
  Derivable from specification:
  - Three main decision types: add replica, remove replica, swap location
  - Each affects different cost components
  - Must validate constraints after each change
  
  Suggested operators:
  ```
  Add: Increases replication cost but may reduce access/transfer cost
  Remove: Reduces replication cost but may increase access cost
  Swap: Changes access cost with minimal replication cost impact
  ```
  
  Rationale: Different operators optimize different trade-offs
  
  ## Deriving Parameters from Problem Structure
  
  All "magic numbers" can be derived from these principles:
  
  1. Cost weight ratios (α₁:α₂:α₃:α₄ = 10:1:5:20):
     - Access cost dominates → focus on latency
     - Bandwidth penalty is severe → avoid violations
     - These ratios justify importance scoring and replication decisions
  
  2. Exponential replication penalty (2^(n-1)):
     - 3 replicas = 4× cost vs 1 replica
     - Justifies limiting high replication to top 10-20% of objects
  
  3. Cross-region penalty (1.5×):
     - 50% additional latency for cross-region access
     - Justifies strong preference for same-region placement
  
  4. Bandwidth threshold (80%):
     - Standard networking practice (avoid congestion)
     - Quadratic penalty above this threshold
  
  5. Capacity utilization:
     - Prefer balanced utilization across caches
     - Avoid hotspots that limit future placement options
  
  ## Why This Matters - Real-World Complexity
  
  Real CDNs face competing objectives:
  - Low latency requires replicating content close to users (costs storage)
  - Dependencies between objects require careful co-location (or pay transfer costs)
  - Bandwidth limits prevent placing all hot content in one region
  - Replication costs grow non-linearly (sync overhead, consistency, storage)
  - Cross-region access incurs additional latency (1.5× penalty)
  
  A naive solution might replicate everything everywhere (high replication cost) or place everything in one region (high latency). You must find the optimal balance.
  
  ## Input Format - Extended Multi-Region Specification
  
  The file `/workdir/data/network.txt` contains the complete network topology:
  
  ```
  n m r u d α₁ α₂ α₃ α₄
  <region_id> <num_caches> <bandwidth_gb_per_hour>
  ...
  <cache_id> <region_id> <capacity_mb>
  ...
  <object_id> <popularity> <size_mb>
  ...
  <object_id> <cache_id> <base_latency_ms>
  ...
  <user_group_id> <region_id> <request_volume_per_hour>
  ...
  <user_group_id> <object_id> <access_frequency>
  ...
  <region_A> <region_B> <transfer_cost_per_mb>
  ...
  [blank line]
  <object_id_A> <object_id_B>
  ...
  ```
  
  Section-by-section:
  
  1. Header: `n m r u d α₁ α₂ α₃ α₄`
     - n = total caches, m = objects, r = regions, u = user groups, d = dependencies
     - α values are cost weights
  
  2. Regions: For each region, its bandwidth capacity (GB/hour)
  
  3. Caches: Each cache with its region and capacity (MB)
  
  4. Objects: Object metadata (popularity 1-5, size in MB)
  
  5. Object-Cache Latencies: Base latency for each object-cache pair (milliseconds)
     - This is the latency within the same region
     - Cross-region access incurs 1.5× penalty on this base latency
  
  6. User Groups: Each user group's region and total request volume (per hour)
  
  7. Access Patterns: Which objects each user group accesses (frequency = requests/hour for that object)
  
  8. Transfer Costs: Cost per MB to transfer data between region pairs
     - Same-region transfers have cost 0.0
     - Cross-region costs vary based on distance
  
  9. Dependencies: After blank line, prerequisite relationships
     - Format: <prerequisite_object> <dependent_object>
     - If object B depends on object A, accessing B may require accessing A
     - If A and B are in different regions, incur transfer cost
  
  ## Output Format - Replication Strategy
  
  You must produce TWO files:
  
  ### 1. `/workdir/replication.txt` - Your replication decisions
  
  One line per object-cache assignment:
  ```
  <object_id> <cache_id>
  ```
  
  CRITICAL NOTES:
  - An object can appear MULTIPLE times (replicated to multiple caches)
  - An object MUST appear AT LEAST ONCE
  - Order doesn't matter in this file
  - More replicas = better latency but higher costs
  
  ### 2. `/workdir/ans.txt` - The optimal cost
  
  A single integer: the total cost from your replication strategy (rounded to nearest integer).
  
  ## Constraints
  
  - 5 ≤ n ≤ 15 (number of caches across all regions)
  - 2 ≤ r ≤ 5 (number of regions)
  - 30 ≤ m ≤ 100 (number of objects)
  - 5 ≤ u ≤ 20 (number of user groups)
  - 0 ≤ d ≤ min(50, m×(m-1)/4) (number of dependencies)
  - 10 ≤ base_latency ≤ 200 milliseconds (latency values in input)
  - 5 ≤ size ≤ 100 MB (per object)
  - 100 ≤ cache_capacity ≤ 2000 MB (per cache)
  - 200 ≤ region_bandwidth ≤ 2000 GB/hour (per region) - HARD LIMIT
  - popularity ∈ {1, 2, 3, 4, 5}
  - 0.0 ≤ transfer_cost ≤ 2.0 (per MB)
  - Dependencies form a DAG (no cycles)
  - Each object can be replicated to 1-5 caches (not unlimited)
  - You do NOT have internet access
  - Python 3 is available
  
  ## Important Implementation Requirements
  
  1. Bandwidth Validation is MANDATORY:
     ```python
     def validate_bandwidth(replication):
         # Calculate actual bandwidth usage per region
         # Return True if all regions within capacity, False otherwise
     
     # Before outputting solution:
     if not validate_bandwidth(replication):
         # Fix violations by removing cross-region replicas
         # or adding in-region replicas
     ```
  
  2. Cross-Region Penalty Must Be Applied:
     ```python
     effective_latency = base_latency * 1.5 if different_region else base_latency
     ```
  
  3. Importance-Based Replication:
     ```python
     importance = popularity * total_accesses * (1 + dependency_factor)
     # Sort objects by importance
     # Allocate more replicas to more important objects
     ```
  
  ## Common Pitfalls to Avoid
  
  1. NOT validating bandwidth constraints before output → FAIL
  2. Ignoring cross-region penalty (1.5×) → Incorrect cost calculation
  3. Replicating everything everywhere → Replication cost explosion
  4. Treating all objects equally → Suboptimal importance ranking
  5. Forgetting dependency transfer costs → Missed optimization opportunity
  6. Not considering request volumes → Popularity ≠ actual usage
  7. Exceeding bandwidth limits → Invalid solution, grading failure
  
  ## Grading Criteria
  
  Your solution will be validated on:
  
  1. ✓ Every object replicated 1-5 times
  2. ✓ Cache capacity constraints satisfied
  3. ✓ Bandwidth constraints satisfied (HARD) 
  4. ✓ Dependencies form DAG
  5. ✓ Claimed cost matches computed cost
  6. ✓ Solution is near-optimal (within 1.30× of baseline)
  
  CRITICAL: If your solution violates bandwidth constraints, it will receive 0 points regardless of cost.

metadata:
  difficulty: very_hard
  category: optimization_algorithms
  tags:
    - multi_objective_optimization
    - replication_strategy
    - resource_allocation
    - network_optimization
    - np_hard_optimization
    - dependency_graphs
    - capacity_constraints
    - bandwidth_management
  estimated_time_minutes: 120
  references:
    - "Inspired by real-world CDN optimization and cloud placement"
    - "Related to multi-commodity network flow and facility location"
    - "Connection to replica placement in distributed systems"
    - "Multi-objective optimization with competing constraints"
  time_limit: 420              # seconds (7 minutes for complex computation)
  memory_limit: 2048           # MB (more memory for complex algorithms)
  max_agent_timeout_sec: 900   # hard cap for agent execution (15 minutes)
  expert_time_estimate_min: 60 # expected time for an expert
  junior_time_estimate_min: 180 # expected time for a junior engineer